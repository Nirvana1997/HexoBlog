---
title: Effective C++笔记(三)
category:
  - c++
tags:
  - c++
  - 学习笔记
date: 2022-06-15 21:35:34
---

第三章来咯~
<!-- more -->

## 条款13：以对象管理资源

这点主要需要记得在new完一个对象后，需要将它放进管理对象中，比如`auto_ptr`、`share_ptr`等智能指针，保证在管理对象中，一旦被管理对象被销毁（如离开作用域），其析构函数能被调用，保证资源正确得释放。

这点中引入了一个概念RAII（Resource AcquisitionIs Initialization），直译过来就是“**资源取得时机便是初始化时机**”，也就是“**以对象管理资源**”的理念。我理解下来，RAII类简单来说就是管理资源的类，通常会用指针去管理new出来的类并负责删除。

## 条款14：在资源管理类中小心copying行为

对于RAII的类，假如可以拷贝，在拷贝时，一定要注意要考虑一并复制其管理的资源，通常的方法有：禁止拷贝、施行引用计数法、复制底部资源即进行“深拷贝”。

## 条款15：在资源管理类中提供对原始资源的访问

对于用来管理资源的RAII类，往往会在使用时，被需要提供访问原始资源。

常用的方法主要分为显式和隐式两种：

* 显式：

  ```cpp
  class Font {
    public:
      ...
      FontHandle get() const { return f; } // 显式转换函数
      ...
    private:
      FontHandle f; // 原始资源
  };
  ```

* 隐式：

  ```cpp
  class Font {
    public:
      ...
      operator FontHandle() const { return f; } // 隐式转换函数
      ...
    private:
      FontHandle f; // 原始资源
  };

总的来说，显式的比较清晰，但是使用时都需要显式调用函数，比较麻烦；隐式的用起来比较方便，但因为隐式调用容易出现一些问题，比如：

```cpp
Font f1;
FontHandle f2 = f1; // 本意是拷贝一个Font对象资源，但是f1被隐式转换成FontHandle，导致进行了浅拷贝
```

## 条款16：成对使用new和delete时要采取相同形式

这条主要讲的是`new`操作和其对应`delete`形式要统一，使用`new[]`的形式的话要对应`delete[]`，反之不使用时也同样对应。

## 条款17：以独立语句将newed对象置入智能指针

有时会需要独立`new`一个对象然后传入函数中，这种情况在调用函数后对象的可能会被保存也可能被析构，不方便直接delete，此时最好将这个指针置入智能指针，这是比较方便和安全的一种做法。

### 参考资料

* 《Effective C\+\+》—— Scott Meyers
