---
title: 'folly:FBString'
category:
  - c++
tags:
  - c++
  - folly
date: 2021-10-28 23:19:55
---

今天研究folly的字符串的实现——FBString。
<!-- more -->

## 1.字符串实现方式

要实现字符串，关键的是两个数据：

1. 对应字符串数据的地址
2. 字符串的长度

对于这些数据的维护方式，主要的有以下几种方式：

###i.eager copy：

eager copy是最简单也是最暴力的字符串数据维护方式。当一个字符串进行拷贝操作时，直接将数据拷贝一份，将数据指针指向拷贝的对象。

这种实现虽然很简单，不用考虑各种复杂的情况，但是当字符串的长度很长时，在空间和时间上都会浪费很多效率。

### ii.COW(copy-on-write)

COW的含义是当对目标字符串需要修改时再进行拷贝，因此拷贝的字符串未进行修改时，和被拷贝字符串使用的是同一片共享的数据。这种实现需要对每个字符串对应的数据计数，当一块数据没有字符串使用以后就将它回收，和c++中的智能指针很类似。

这种方式处理较长的字符串时，可以避免不需要的拷贝，节省效率，但是由于需要维护一个refcount，这个操作是一个原子操作，频繁进行拷贝的话，会比较消耗效率。

关于COW，我看到了个比较有意思的情况：

```c++
std::string s("str");
const char* p = s.data();
{
    std::string s2(s);
    (void) s[0];
}
std::cout << *p << '\n';
```

下面这段代码在c++11（c++11中禁止了COW）标准下可以正常运行，但是用使用COW的gcc版本去执行会发现p变成了一个野指针。这是因为s2构造时，与s共享了同一片数据，但使用非const的[]操作符取出的对象，编译器会认为你要对其进行修改，所以会重新拷贝一份“str”的数据并让s指向新的数据，然后当代码走出中间一个代码段后，s2的生命周期到了，而它指向的字符串数据没有被共享，因此p所指向的数据被析构了，p也变成了野指针。

